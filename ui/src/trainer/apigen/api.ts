// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * NERd
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "http://localhost:3000".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface CreateNERdCorpus
 */
export interface CreateNERdCorpus {
    /**
     * 
     * @type {string}
     * @memberof CreateNERdCorpus
     */
    base_corpus_name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNERdCorpus
     */
    corpus_name: string;
}

/**
 * 
 * @export
 * @interface DocumentModel
 */
export interface DocumentModel {
    /**
     * 
     * @type {Array<Nested6>}
     * @memberof DocumentModel
     */
    ents?: Array<Nested6>;
    /**
     * 
     * @type {Array<Nested7>}
     * @memberof DocumentModel
     */
    sents?: Array<Nested7>;
    /**
     * 
     * @type {string}
     * @memberof DocumentModel
     */
    text?: string;
    /**
     * 
     * @type {Array<Nested8>}
     * @memberof DocumentModel
     */
    tokens?: Array<Nested8>;
}

/**
 * 
 * @export
 * @interface HttpError
 */
export interface HttpError {
    /**
     * A description of the error
     * @type {string}
     * @memberof HttpError
     */
    status: string;
}

/**
 * 
 * @export
 * @interface MetadataFields
 */
export interface MetadataFields {
    /**
     * 
     * @type {number}
     * @memberof MetadataFields
     */
    queued: number;
    /**
     * 
     * @type {number}
     * @memberof MetadataFields
     */
    trained: number;
}

/**
 * 
 * @export
 * @interface NERType
 */
export interface NERType {
    /**
     * 
     * @type {string}
     * @memberof NERType
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof NERType
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof NERType
     */
    color?: string;
}

/**
 * 
 * @export
 * @interface NERdCorpus
 */
export interface NERdCorpus {
    /**
     * 
     * @type {string}
     * @memberof NERdCorpus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NERdCorpus
     */
    types?: string;
    /**
     * 
     * @type {string}
     * @memberof NERdCorpus
     */
    _cls?: string;
    /**
     * 
     * @type {string}
     * @memberof NERdCorpus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NERdCorpus
     */
    parent?: string;
    /**
     * 
     * @type {Array<Nested>}
     * @memberof NERdCorpus
     */
    dataset?: Array<Nested>;
}

/**
 * 
 * @export
 * @interface Nested
 */
export interface Nested {
    /**
     * 
     * @type {Array<Nested>}
     * @memberof Nested
     */
    trained?: Array<Nested>;
    /**
     * 
     * @type {Nested3}
     * @memberof Nested
     */
    original?: Nested3;
}

/**
 * 
 * @export
 * @interface Nested1
 */
export interface Nested1 {
    /**
     * 
     * @type {number}
     * @memberof Nested1
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested1
     */
    end?: number;
}

/**
 * 
 * @export
 * @interface Nested2
 */
export interface Nested2 {
    /**
     * 
     * @type {string}
     * @memberof Nested2
     */
    pos?: string;
    /**
     * 
     * @type {string}
     * @memberof Nested2
     */
    dep?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested2
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested2
     */
    end?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested2
     */
    head?: number;
    /**
     * 
     * @type {string}
     * @memberof Nested2
     */
    tag?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested2
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface Nested3
 */
export interface Nested3 {
    /**
     * 
     * @type {Array<Nested3>}
     * @memberof Nested3
     */
    ents?: Array<Nested3>;
    /**
     * 
     * @type {Array<Nested4>}
     * @memberof Nested3
     */
    sents?: Array<Nested4>;
    /**
     * 
     * @type {Array<Nested5>}
     * @memberof Nested3
     */
    tokens?: Array<Nested5>;
    /**
     * 
     * @type {string}
     * @memberof Nested3
     */
    text?: string;
}

/**
 * 
 * @export
 * @interface Nested4
 */
export interface Nested4 {
    /**
     * 
     * @type {number}
     * @memberof Nested4
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested4
     */
    end?: number;
}

/**
 * 
 * @export
 * @interface Nested5
 */
export interface Nested5 {
    /**
     * 
     * @type {string}
     * @memberof Nested5
     */
    pos?: string;
    /**
     * 
     * @type {string}
     * @memberof Nested5
     */
    dep?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested5
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested5
     */
    end?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested5
     */
    head?: number;
    /**
     * 
     * @type {string}
     * @memberof Nested5
     */
    tag?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested5
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface Nested6
 */
export interface Nested6 {
    /**
     * 
     * @type {string}
     * @memberof Nested6
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested6
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested6
     */
    end?: number;
}

/**
 * 
 * @export
 * @interface Nested7
 */
export interface Nested7 {
    /**
     * 
     * @type {number}
     * @memberof Nested7
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested7
     */
    end?: number;
}

/**
 * 
 * @export
 * @interface Nested8
 */
export interface Nested8 {
    /**
     * 
     * @type {string}
     * @memberof Nested8
     */
    pos?: string;
    /**
     * 
     * @type {string}
     * @memberof Nested8
     */
    dep?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested8
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested8
     */
    end?: number;
    /**
     * 
     * @type {number}
     * @memberof Nested8
     */
    head?: number;
    /**
     * 
     * @type {string}
     * @memberof Nested8
     */
    tag?: string;
    /**
     * 
     * @type {number}
     * @memberof Nested8
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface NewText
 */
export interface NewText {
    /**
     * 
     * @type {string}
     * @memberof NewText
     */
    text: string;
}

/**
 * 
 * @export
 * @interface Register
 */
export interface Register {
    /**
     * 
     * @type {string}
     * @memberof Register
     */
    plain_password?: string;
    /**
     * 
     * @type {string}
     * @memberof Register
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Register
     */
    email: string;
}

/**
 * 
 * @export
 * @interface RoleList
 */
export interface RoleList {
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleList
     */
    roles?: Array<string>;
}

/**
 * 
 * @export
 * @interface SystemCorpus
 */
export interface SystemCorpus {
    /**
     * 
     * @type {string}
     * @memberof SystemCorpus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemCorpus
     */
    types?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemCorpus
     */
    _cls?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemCorpus
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemCorpus
     */
    spacy_model?: string;
}

/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    grant_type?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    password?: string;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    roles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email: string;
}

/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * A temporary JWT
     * @type {string}
     * @memberof UserCredentials
     */
    access_token: string;
    /**
     * A refresh token
     * @type {string}
     * @memberof UserCredentials
     */
    refresh_token: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCredentials
     */
    roles?: Array<string>;
}

/**
 * 
 * @export
 * @interface UserPayload
 */
export interface UserPayload {
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    plain_password?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPayload
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPayload
     */
    roles?: Array<string>;
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate new access and refresh tokens with password grant_type
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(token: Token, options: any = {}): RequestArgs {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling createAccessToken.');
            }
            const localVarPath = `/api/auth/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Token" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(token || {}) : (token || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {string} grant_type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(grant_type: string, options: any = {}): RequestArgs {
            // verify required parameter 'grant_type' is not null or undefined
            if (grant_type === null || grant_type === undefined) {
                throw new RequiredError('grant_type','Required parameter grant_type was null or undefined when calling refreshAccessToken.');
            }
            const localVarPath = `/api/auth/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (grant_type !== undefined) {
                localVarQueryParameter['grant_type'] = grant_type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns user credentials to skip login on register
         * @summary Register a new user
         * @param {Register} register 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(register: Register, options: any = {}): RequestArgs {
            // verify required parameter 'register' is not null or undefined
            if (register === null || register === undefined) {
                throw new RequiredError('register','Required parameter register was null or undefined when calling registerUser.');
            }
            const localVarPath = `/api/auth/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Register" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(register || {}) : (register || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Generate new access and refresh tokens with password grant_type
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(token: Token, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentials> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).createAccessToken(token, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Refresh access token
         * @param {string} grant_type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(grant_type: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentials> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).refreshAccessToken(grant_type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Returns user credentials to skip login on register
         * @summary Register a new user
         * @param {Register} register 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(register: Register, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentials> {
            const localVarAxiosArgs = AuthApiAxiosParamCreator(configuration).registerUser(register, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Generate new access and refresh tokens with password grant_type
         * @param {Token} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(token: Token, options?: any) {
            return AuthApiFp(configuration).createAccessToken(token, options)(axios, basePath);
        },
        /**
         * 
         * @summary Refresh access token
         * @param {string} grant_type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAccessToken(grant_type: string, options?: any) {
            return AuthApiFp(configuration).refreshAccessToken(grant_type, options)(axios, basePath);
        },
        /**
         * Returns user credentials to skip login on register
         * @summary Register a new user
         * @param {Register} register 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(register: Register, options?: any) {
            return AuthApiFp(configuration).registerUser(register, options)(axios, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Generate new access and refresh tokens with password grant_type
     * @param {Token} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public createAccessToken(token: Token, options?: any) {
        return AuthApiFp(this.configuration).createAccessToken(token, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Refresh access token
     * @param {string} grant_type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAccessToken(grant_type: string, options?: any) {
        return AuthApiFp(this.configuration).refreshAccessToken(grant_type, options)(this.axios, this.basePath);
    }

    /**
     * Returns user credentials to skip login on register
     * @summary Register a new user
     * @param {Register} register 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerUser(register: Register, options?: any) {
        return AuthApiFp(this.configuration).registerUser(register, options)(this.axios, this.basePath);
    }

}

/**
 * CorporaApi - axios parameter creator
 * @export
 */
export const CorporaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Force a training event
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceTraining(corpus_name: string, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling forceTraining.');
            }
            const localVarPath = `/api/corpora/{corpus_name}/refresh`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns metadata for a given corpus
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorpus(corpus_name: string, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling getCorpus.');
            }
            const localVarPath = `/api/corpora/{corpus_name}`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the list of available entity types
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes(corpus_name: string, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling getEntityTypes.');
            }
            const localVarPath = `/api/corpora/{corpus_name}/entity-types`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Processes given text with SpaCy
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNerDocument(corpus_name: string, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling getNerDocument.');
            }
            const localVarPath = `/api/corpora/{corpus_name}/ner`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available corpora
         * @param {number} [page] 
         * @param {number} [page_size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCorpora(page?: number, page_size?: number, options: any = {}): RequestArgs {
            const localVarPath = `/api/corpora`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List available SpaCy base corpus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystemCorpora(options: any = {}): RequestArgs {
            const localVarPath = `/api/corpora/system`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a new text to used for training
         * @param {string} corpus_name 
         * @param {NewText} new_text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueTrainingText(corpus_name: string, new_text: NewText, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling queueTrainingText.');
            }
            // verify required parameter 'new_text' is not null or undefined
            if (new_text === null || new_text === undefined) {
                throw new RequiredError('new_text','Required parameter new_text was null or undefined when calling queueTrainingText.');
            }
            const localVarPath = `/api/corpora/{corpus_name}/training`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewText" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(new_text || {}) : (new_text || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * :raises Unauthorized: When current user has insufficient permissions :raises BadRequest: When couldn't delete the corpus
         * @summary Deletes a corpus
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCorpus(corpus_name: string, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling removeCorpus.');
            }
            const localVarPath = `/api/corpora/{corpus_name}`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a corpus from a given SpaCy corpus
         * @param {CreateNERdCorpus} create_ne_rd_corpus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCorpus(create_ne_rd_corpus: CreateNERdCorpus, options: any = {}): RequestArgs {
            // verify required parameter 'create_ne_rd_corpus' is not null or undefined
            if (create_ne_rd_corpus === null || create_ne_rd_corpus === undefined) {
                throw new RequiredError('create_ne_rd_corpus','Required parameter create_ne_rd_corpus was null or undefined when calling upsertCorpus.');
            }
            const localVarPath = `/api/corpora`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateNERdCorpus" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(create_ne_rd_corpus || {}) : (create_ne_rd_corpus || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or create entity types
         * @param {string} corpus_name 
         * @param {NERType} ner_type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEntityTypes(corpus_name: string, ner_type: NERType, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling upsertEntityTypes.');
            }
            // verify required parameter 'ner_type' is not null or undefined
            if (ner_type === null || ner_type === undefined) {
                throw new RequiredError('ner_type','Required parameter ner_type was null or undefined when calling upsertEntityTypes.');
            }
            const localVarPath = `/api/corpora/{corpus_name}/entity-types`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NERType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(ner_type || {}) : (ner_type || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Model entity recognition correction TODO: Document this
         * @param {string} corpus_name 
         * @param {DocumentModel} document_model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertNerDocument(corpus_name: string, document_model: DocumentModel, options: any = {}): RequestArgs {
            // verify required parameter 'corpus_name' is not null or undefined
            if (corpus_name === null || corpus_name === undefined) {
                throw new RequiredError('corpus_name','Required parameter corpus_name was null or undefined when calling upsertNerDocument.');
            }
            // verify required parameter 'document_model' is not null or undefined
            if (document_model === null || document_model === undefined) {
                throw new RequiredError('document_model','Required parameter document_model was null or undefined when calling upsertNerDocument.');
            }
            const localVarPath = `/api/corpora/{corpus_name}/ner`
                .replace(`{${"corpus_name"}}`, encodeURIComponent(String(corpus_name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DocumentModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(document_model || {}) : (document_model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorporaApi - functional programming interface
 * @export
 */
export const CorporaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Force a training event
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceTraining(corpus_name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).forceTraining(corpus_name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns metadata for a given corpus
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorpus(corpus_name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataFields> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).getCorpus(corpus_name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns the list of available entity types
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes(corpus_name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NERType>> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).getEntityTypes(corpus_name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Processes given text with SpaCy
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNerDocument(corpus_name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentModel> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).getNerDocument(corpus_name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List available corpora
         * @param {number} [page] 
         * @param {number} [page_size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCorpora(page?: number, page_size?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NERdCorpus>> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).listCorpora(page, page_size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary List available SpaCy base corpus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystemCorpora(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SystemCorpus>> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).listSystemCorpora(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Add a new text to used for training
         * @param {string} corpus_name 
         * @param {NewText} new_text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueTrainingText(corpus_name: string, new_text: NewText, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).queueTrainingText(corpus_name, new_text, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * :raises Unauthorized: When current user has insufficient permissions :raises BadRequest: When couldn't delete the corpus
         * @summary Deletes a corpus
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCorpus(corpus_name: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).removeCorpus(corpus_name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Creates a corpus from a given SpaCy corpus
         * @param {CreateNERdCorpus} create_ne_rd_corpus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCorpus(create_ne_rd_corpus: CreateNERdCorpus, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NERdCorpus> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).upsertCorpus(create_ne_rd_corpus, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Update or create entity types
         * @param {string} corpus_name 
         * @param {NERType} ner_type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEntityTypes(corpus_name: string, ner_type: NERType, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).upsertEntityTypes(corpus_name, ner_type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Model entity recognition correction TODO: Document this
         * @param {string} corpus_name 
         * @param {DocumentModel} document_model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertNerDocument(corpus_name: string, document_model: DocumentModel, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response> {
            const localVarAxiosArgs = CorporaApiAxiosParamCreator(configuration).upsertNerDocument(corpus_name, document_model, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CorporaApi - factory interface
 * @export
 */
export const CorporaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Force a training event
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceTraining(corpus_name: string, options?: any) {
            return CorporaApiFp(configuration).forceTraining(corpus_name, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns metadata for a given corpus
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorpus(corpus_name: string, options?: any) {
            return CorporaApiFp(configuration).getCorpus(corpus_name, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns the list of available entity types
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntityTypes(corpus_name: string, options?: any) {
            return CorporaApiFp(configuration).getEntityTypes(corpus_name, options)(axios, basePath);
        },
        /**
         * 
         * @summary Processes given text with SpaCy
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNerDocument(corpus_name: string, options?: any) {
            return CorporaApiFp(configuration).getNerDocument(corpus_name, options)(axios, basePath);
        },
        /**
         * 
         * @summary List available corpora
         * @param {number} [page] 
         * @param {number} [page_size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCorpora(page?: number, page_size?: number, options?: any) {
            return CorporaApiFp(configuration).listCorpora(page, page_size, options)(axios, basePath);
        },
        /**
         * 
         * @summary List available SpaCy base corpus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSystemCorpora(options?: any) {
            return CorporaApiFp(configuration).listSystemCorpora(options)(axios, basePath);
        },
        /**
         * 
         * @summary Add a new text to used for training
         * @param {string} corpus_name 
         * @param {NewText} new_text 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueTrainingText(corpus_name: string, new_text: NewText, options?: any) {
            return CorporaApiFp(configuration).queueTrainingText(corpus_name, new_text, options)(axios, basePath);
        },
        /**
         * :raises Unauthorized: When current user has insufficient permissions :raises BadRequest: When couldn't delete the corpus
         * @summary Deletes a corpus
         * @param {string} corpus_name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCorpus(corpus_name: string, options?: any) {
            return CorporaApiFp(configuration).removeCorpus(corpus_name, options)(axios, basePath);
        },
        /**
         * 
         * @summary Creates a corpus from a given SpaCy corpus
         * @param {CreateNERdCorpus} create_ne_rd_corpus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertCorpus(create_ne_rd_corpus: CreateNERdCorpus, options?: any) {
            return CorporaApiFp(configuration).upsertCorpus(create_ne_rd_corpus, options)(axios, basePath);
        },
        /**
         * 
         * @summary Update or create entity types
         * @param {string} corpus_name 
         * @param {NERType} ner_type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEntityTypes(corpus_name: string, ner_type: NERType, options?: any) {
            return CorporaApiFp(configuration).upsertEntityTypes(corpus_name, ner_type, options)(axios, basePath);
        },
        /**
         * 
         * @summary Model entity recognition correction TODO: Document this
         * @param {string} corpus_name 
         * @param {DocumentModel} document_model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertNerDocument(corpus_name: string, document_model: DocumentModel, options?: any) {
            return CorporaApiFp(configuration).upsertNerDocument(corpus_name, document_model, options)(axios, basePath);
        },
    };
};

/**
 * CorporaApi - object-oriented interface
 * @export
 * @class CorporaApi
 * @extends {BaseAPI}
 */
export class CorporaApi extends BaseAPI {
    /**
     * 
     * @summary Force a training event
     * @param {string} corpus_name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public forceTraining(corpus_name: string, options?: any) {
        return CorporaApiFp(this.configuration).forceTraining(corpus_name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns metadata for a given corpus
     * @param {string} corpus_name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public getCorpus(corpus_name: string, options?: any) {
        return CorporaApiFp(this.configuration).getCorpus(corpus_name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns the list of available entity types
     * @param {string} corpus_name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public getEntityTypes(corpus_name: string, options?: any) {
        return CorporaApiFp(this.configuration).getEntityTypes(corpus_name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Processes given text with SpaCy
     * @param {string} corpus_name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public getNerDocument(corpus_name: string, options?: any) {
        return CorporaApiFp(this.configuration).getNerDocument(corpus_name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List available corpora
     * @param {number} [page] 
     * @param {number} [page_size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public listCorpora(page?: number, page_size?: number, options?: any) {
        return CorporaApiFp(this.configuration).listCorpora(page, page_size, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary List available SpaCy base corpus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public listSystemCorpora(options?: any) {
        return CorporaApiFp(this.configuration).listSystemCorpora(options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Add a new text to used for training
     * @param {string} corpus_name 
     * @param {NewText} new_text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public queueTrainingText(corpus_name: string, new_text: NewText, options?: any) {
        return CorporaApiFp(this.configuration).queueTrainingText(corpus_name, new_text, options)(this.axios, this.basePath);
    }

    /**
     * :raises Unauthorized: When current user has insufficient permissions :raises BadRequest: When couldn't delete the corpus
     * @summary Deletes a corpus
     * @param {string} corpus_name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public removeCorpus(corpus_name: string, options?: any) {
        return CorporaApiFp(this.configuration).removeCorpus(corpus_name, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Creates a corpus from a given SpaCy corpus
     * @param {CreateNERdCorpus} create_ne_rd_corpus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public upsertCorpus(create_ne_rd_corpus: CreateNERdCorpus, options?: any) {
        return CorporaApiFp(this.configuration).upsertCorpus(create_ne_rd_corpus, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Update or create entity types
     * @param {string} corpus_name 
     * @param {NERType} ner_type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public upsertEntityTypes(corpus_name: string, ner_type: NERType, options?: any) {
        return CorporaApiFp(this.configuration).upsertEntityTypes(corpus_name, ner_type, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Model entity recognition correction TODO: Document this
     * @param {string} corpus_name 
     * @param {DocumentModel} document_model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorporaApi
     */
    public upsertNerDocument(corpus_name: string, document_model: DocumentModel, options?: any) {
        return CorporaApiFp(this.configuration).upsertNerDocument(corpus_name, document_model, options)(this.axios, this.basePath);
    }

}

/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of available roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options: any = {}): RequestArgs {
            const localVarPath = `/api/roles/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of available roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleList> {
            const localVarAxiosArgs = RolesApiAxiosParamCreator(configuration).listRoles(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Returns a list of available roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(options?: any) {
            return RolesApiFp(configuration).listRoles(options)(axios, basePath);
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of available roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public listRoles(options?: any) {
        return RolesApiFp(this.configuration).listRoles(options)(this.axios, this.basePath);
    }

}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user by email
         * @param {string} user_email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user_email: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_email' is not null or undefined
            if (user_email === null || user_email === undefined) {
                throw new RequiredError('user_email','Required parameter user_email was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/api/users/{user_email}`
                .replace(`{${"user_email"}}`, encodeURIComponent(String(user_email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of existing users
         * @param {number} [page] 
         * @param {number} [page_size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, page_size?: number, options: any = {}): RequestArgs {
            const localVarPath = `/api/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patches the user entity
         * @param {string} user_email 
         * @param {UserPayload} user_payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user_email: string, user_payload: UserPayload, options: any = {}): RequestArgs {
            // verify required parameter 'user_email' is not null or undefined
            if (user_email === null || user_email === undefined) {
                throw new RequiredError('user_email','Required parameter user_email was null or undefined when calling updateUser.');
            }
            // verify required parameter 'user_payload' is not null or undefined
            if (user_payload === null || user_payload === undefined) {
                throw new RequiredError('user_payload','Required parameter user_payload was null or undefined when calling updateUser.');
            }
            const localVarPath = `/api/users/{user_email}`
                .replace(`{${"user_email"}}`, encodeURIComponent(String(user_email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(user_payload || {}) : (user_payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets user entity by email
         * @param {string} user_email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetails(user_email: string, options: any = {}): RequestArgs {
            // verify required parameter 'user_email' is not null or undefined
            if (user_email === null || user_email === undefined) {
                throw new RequiredError('user_email','Required parameter user_email was null or undefined when calling userDetails.');
            }
            const localVarPath = `/api/users/{user_email}`
                .replace(`{${"user_email"}}`, encodeURIComponent(String(user_email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2Password required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("oAuth2Password", ["user", "admin"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete user by email
         * @param {string} user_email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user_email: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).deleteUser(user_email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Returns a list of existing users
         * @param {number} [page] 
         * @param {number} [page_size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, page_size?: number, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).listUsers(page, page_size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Patches the user entity
         * @param {string} user_email 
         * @param {UserPayload} user_payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user_email: string, user_payload: UserPayload, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).updateUser(user_email, user_payload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * 
         * @summary Gets user entity by email
         * @param {string} user_email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetails(user_email: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
            const localVarAxiosArgs = UsersApiAxiosParamCreator(configuration).userDetails(user_email, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete user by email
         * @param {string} user_email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(user_email: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(user_email, options)(axios, basePath);
        },
        /**
         * 
         * @summary Returns a list of existing users
         * @param {number} [page] 
         * @param {number} [page_size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(page?: number, page_size?: number, options?: any) {
            return UsersApiFp(configuration).listUsers(page, page_size, options)(axios, basePath);
        },
        /**
         * 
         * @summary Patches the user entity
         * @param {string} user_email 
         * @param {UserPayload} user_payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user_email: string, user_payload: UserPayload, options?: any) {
            return UsersApiFp(configuration).updateUser(user_email, user_payload, options)(axios, basePath);
        },
        /**
         * 
         * @summary Gets user entity by email
         * @param {string} user_email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDetails(user_email: string, options?: any) {
            return UsersApiFp(configuration).userDetails(user_email, options)(axios, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete user by email
     * @param {string} user_email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(user_email: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(user_email, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of existing users
     * @param {number} [page] 
     * @param {number} [page_size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(page?: number, page_size?: number, options?: any) {
        return UsersApiFp(this.configuration).listUsers(page, page_size, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Patches the user entity
     * @param {string} user_email 
     * @param {UserPayload} user_payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(user_email: string, user_payload: UserPayload, options?: any) {
        return UsersApiFp(this.configuration).updateUser(user_email, user_payload, options)(this.axios, this.basePath);
    }

    /**
     * 
     * @summary Gets user entity by email
     * @param {string} user_email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userDetails(user_email: string, options?: any) {
        return UsersApiFp(this.configuration).userDetails(user_email, options)(this.axios, this.basePath);
    }

}

